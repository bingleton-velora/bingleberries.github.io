<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Binding of Issaic</title>
  <style>html,body{height:100%;margin:0;overflow:hidden;background:#111}canvas{display:block}</style>
</head>
<body>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
// MINI MARIO-KART-LIKE â€” single HTML file, minimal and janky but playable.
// Controls: W / Up = gas, S / Down = brake, A / Left = steer left, D / Right = steer right, Space = handbrake (drift)

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 2000);
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth, innerHeight);
renderer.setClearColor(0x87ceeb); // sky blue
document.body.appendChild(renderer.domElement);

// simple ambient + directional lights
const amb = new THREE.AmbientLight(0xffffff, 0.6); scene.add(amb);
const dir = new THREE.DirectionalLight(0xffffff, 0.8); dir.position.set(5,10,2); scene.add(dir);

// ground (simple race oval)
const groundGeo = new THREE.PlaneGeometry(200,200,4,4);
const groundMat = new THREE.MeshStandardMaterial({color:0x228b22});
const ground = new THREE.Mesh(groundGeo, groundMat); ground.rotation.x = -Math.PI/2; scene.add(ground);

// track: create a basic oval path by stamping a textured plane
const trackGroup = new THREE.Group();
function makeTrack(){
  // track base (darker green in middle)
  const trackMat = new THREE.MeshStandardMaterial({color:0x5c3b1f});
  const outer = new THREE.RingGeometry(40, 80, 64);
  const outerMesh = new THREE.Mesh(outer, new THREE.MeshStandardMaterial({color:0x444}));
  outerMesh.rotation.x = -Math.PI/2; trackGroup.add(outerMesh);
  // asphalt strip
  const asphalt = new THREE.RingGeometry(28, 40, 64);
  const asphaltMesh = new THREE.Mesh(asphalt, new THREE.MeshStandardMaterial({color:0x222}));
  asphaltMesh.rotation.x = -Math.PI/2; trackGroup.add(asphaltMesh);
  // inner grass
  const inner = new THREE.RingGeometry(0, 28, 64);
  const innerMesh = new THREE.Mesh(inner, new THREE.MeshStandardMaterial({color:0x2e8b57}));
  innerMesh.rotation.x = -Math.PI/2; trackGroup.add(innerMesh);
}
makeTrack(); scene.add(trackGroup);

// simple barriers along outside
const barriers = new THREE.Group();
for(let i=0;i<64;i++){
  const angle = (i/64)*Math.PI*2;
  const x = Math.cos(angle)*78, z = Math.sin(angle)*78;
  const b = new THREE.Mesh(new THREE.BoxGeometry(4,3,8), new THREE.MeshStandardMaterial({color:0x993333}));
  b.position.set(x,1.5,z); b.lookAt(0,1.5,0); barriers.add(b);
}
scene.add(barriers);

// PLAYER KART (simple box + wheels)
const kart = new THREE.Group();
const body = new THREE.Mesh(new THREE.BoxGeometry(2.4,0.6,3.2), new THREE.MeshStandardMaterial({color:0xff5500})); body.position.y = 0.6; kart.add(body);
// wheels
function makeWheel(){ return new THREE.Mesh(new THREE.CylinderGeometry(0.35,0.35,0.5,12), new THREE.MeshStandardMaterial({color:0x111})); }
const w1 = makeWheel(); w1.rotation.z = Math.PI/2; w1.position.set(1.1,0.25,1.1); kart.add(w1);
const w2 = makeWheel(); w2.rotation.z = Math.PI/2; w2.position.set(-1.1,0.25,1.1); kart.add(w2);
const w3 = makeWheel(); w3.rotation.z = Math.PI/2; w3.position.set(1.1,0.25,-1.1); kart.add(w3);
const w4 = makeWheel(); w4.rotation.z = Math.PI/2; w4.position.set(-1.1,0.25,-1.1); kart.add(w4);

scene.add(kart);
kart.position.set(0,0.01,40);

// camera follow
camera.position.set(0,6,12);
camera.lookAt(kart.position);

// simple physics state
const state = {
  speed:0,
  angle:0, // heading in radians
  steer:0,
  pos:new THREE.Vector3(kart.position.x, kart.position.y, kart.position.z),
  lap:0
};

// input
const keys = {};
window.addEventListener('keydown', e=> keys[e.key.toLowerCase()] = true);
window.addEventListener('keyup', e=> keys[e.key.toLowerCase()] = false);

// basic AI opponents (follow path points)
const aiKarts = [];
function spawnAI(color, zOffset){
  const g = new THREE.Group();
  g.add(new THREE.Mesh(new THREE.BoxGeometry(2.2,0.6,3), new THREE.MeshStandardMaterial({color})));
  g.position.set(0,0.01, 40 + zOffset);
  scene.add(g);
  aiKarts.push({mesh:g, speed:0.06, angle:0, pathT: zOffset>0?0.2:0});
}
spawnAI(0x0066ff, -4);
spawnAI(0x00ff66, 4);

// path helper: parametric oval track function
function trackPos(t){ // t in [0,1)
  const a = t * Math.PI*2;
  // oval: x=cos(a)*50, z=sin(a)*30 (elongated)
  return new THREE.Vector3(Math.cos(a)*50, 0, Math.sin(a)*30);
}

function trackTFromPos(pos){ // naive: find nearest t by sampling
  let bestT=0, bestD=Infinity;
  for(let i=0;i<360;i++){
    const t=i/360; const p = trackPos(t);
    const d = p.distanceToSquared(pos);
    if(d<bestD){ bestD=d; bestT=t; }
  }
  return bestT;
}

// helpers
function clamp(v,min,max){ return Math.max(min, Math.min(max, v)); }

// game loop
let last = performance.now();
function update(dt){
  // input: accelerate / brake
  const accel = (keys['w']||keys['arrowup']) ? 0.15 : (keys['s']||keys['arrowdown']) ? -0.2 : -0.05;
  // handbrake makes sharper turn
  const handbrake = keys[' '];
  state.speed += accel * dt * 60; // scale for framerate
  state.speed = clamp(state.speed, -2.5, 6);

  // steering
  const steerInput = (keys['a']||keys['arrowleft'] ? 1 : 0) - (keys['d']||keys['arrowright'] ? 1 : 0);
  const steerStrength = handbrake ? 0.06 : 0.03;
  state.steer = steerInput * steerStrength * (1 - Math.exp(-Math.abs(state.speed)/2));

  // update heading
  state.angle += state.steer * state.speed * dt;

  // integrate position
  const forward = new THREE.Vector3(Math.sin(state.angle), 0, Math.cos(state.angle));
  state.pos.add(forward.multiplyScalar(state.speed * dt));

  // simple friction
  state.speed *= 0.995;

  // collide with outer barrier roughly
  const r = Math.sqrt(state.pos.x*state.pos.x + state.pos.z*state.pos.z);
  if(r > 78){ // hit outside
    // bounce a bit
    state.pos.addScaledVector(state.pos.clone().normalize(), -2);
    state.speed *= 0.6;
  }

  // apply to kart mesh
  kart.position.copy(state.pos);
  kart.rotation.y = -state.angle;

  // camera follow third-person
  const camOffset = new THREE.Vector3(Math.sin(state.angle)*-10, 6, Math.cos(state.angle)*-10);
  const camPos = state.pos.clone().add(camOffset);
  camera.position.lerp(camPos, 0.12);
  camera.lookAt(kart.position.clone().add(new THREE.Vector3(0,1,0)));

  // update AI karts to follow parametric path
  aiKarts.forEach(ai => {
    ai.pathT += ai.speed * dt * 0.8;
    if(ai.pathT > 1) ai.pathT -= 1;
    const p = trackPos(ai.pathT);
    ai.mesh.position.lerp(p, 0.05);
    const next = trackPos((ai.pathT + 0.01) % 1);
    const dir = new THREE.Vector3().subVectors(next, p).normalize();
    ai.mesh.lookAt(p.clone().add(dir));
  });
}

function render(){ renderer.render(scene, camera); }

function loop(){
  const now = performance.now();
  const dt = Math.min(0.05, (now - last)/1000);
  last = now;
  update(dt);
  render();
  requestAnimationFrame(loop);
}

// HUD (minimal overlay)
const hud = document.createElement('div');
hud.style.position='absolute'; hud.style.left='10px'; hud.style.top='10px'; hud.style.color='#fff'; hud.style.fontFamily='monospace'; hud.style.fontSize='14px';
hud.style.background='rgba(0,0,0,0.25)'; hud.style.padding='6px 8px'; hud.innerHTML = 'Speed: 0';
document.body.appendChild(hud);

// update HUD in a cheap interval
setInterval(()=>{ hud.innerHTML = `Speed: ${Math.round(state.speed*60)}<br>Pos: ${state.pos.x.toFixed(1)}, ${state.pos.z.toFixed(1)}`; }, 120);

// start
loop();

// resize handling
window.addEventListener('resize', ()=>{ camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth, innerHeight); });

</script>
</body>
</html>
